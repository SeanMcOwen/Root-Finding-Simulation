<p>For explanations of generalized dynamical systems as well as how the mathematical specification library works in detail, please consult the documentation <a href="https://github.com/BlockScience/MSML/tree/main/docs">here</a></p>Graph Legend:<br/>Cylinder: Entity<br/>Orange Diamond: Boundary Action<br/>Red Square: Policy<br/>Blue Circle: Mechanism<br/>Transparent Circle: State Variable<h2>Action Maps</h2><?xml version="1.0" encoding="UTF-8" standalone="no"?>

<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN"

 "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">

<!-- Generated by graphviz version 2.50.0 (0)

 -->

<!-- Title: Initialization Control Action Pages: 1 -->

<svg width="321pt" height="292pt"

 viewBox="0.00 0.00 320.51 292.00" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">

<g id="graph0" class="graph" transform="scale(1 1) rotate(0) translate(4 288)">

<title>Initialization Control Action</title>

<polygon fill="white" stroke="transparent" points="-4,4 -4,-288 316.51,-288 316.51,4 -4,4"/>

<!-- Initialization Control Action -->

<g id="node1" class="node">

<title>Initialization Control Action</title>

<polygon fill="yellow" stroke="yellow" points="156.26,-284 0.24,-266 156.26,-248 312.27,-266 156.26,-284"/>

<text text-anchor="middle" x="156.26" y="-262.3" font-family="Times,serif" font-size="14.00">Initialization Control Action</text>

</g>

<!-- Update X Mechanism -->

<g id="node2" class="node">

<title>Update X Mechanism</title>

<ellipse fill="#e0eeee" stroke="#e0eeee" cx="156.26" cy="-164" rx="89.08" ry="18"/>

<text text-anchor="middle" x="156.26" y="-160.3" font-family="Times,serif" font-size="14.00">Update X Mechanism</text>

</g>

<!-- Initialization Control Action&#45;&gt;Update X Mechanism -->

<g id="edge1" class="edge">

<title>Initialization Control Action&#45;&gt;Update X Mechanism</title>

<path fill="none" stroke="black" d="M156.26,-247.58C156.26,-232.38 156.26,-210.07 156.26,-192.46"/>

<polygon fill="black" stroke="black" points="159.76,-192.22 156.26,-182.22 152.76,-192.22 159.76,-192.22"/>

<text text-anchor="middle" x="182.76" y="-218.8" font-family="Times,serif" font-size="14.00">Update X</text>

<text text-anchor="middle" x="182.76" y="-203.8" font-family="Times,serif" font-size="14.00">Space</text>

</g>

<!-- Global.X -->

<g id="node4" class="node">

<title>Global.X</title>

<ellipse fill="none" stroke="black" cx="156.26" cy="-91" rx="43.59" ry="18"/>

<text text-anchor="middle" x="156.26" y="-87.3" font-family="Times,serif" font-size="14.00">Global.X</text>

</g>

<!-- Update X Mechanism&#45;&gt;Global.X -->

<g id="edge2" class="edge">

<title>Update X Mechanism&#45;&gt;Global.X</title>

<path fill="none" stroke="black" d="M156.26,-145.81C156.26,-137.79 156.26,-128.05 156.26,-119.07"/>

<polygon fill="black" stroke="black" points="159.76,-119.03 156.26,-109.03 152.76,-119.03 159.76,-119.03"/>

</g>

<!-- Global_2 -->

<g id="node3" class="node">

<title>Global_2</title>

<path fill="none" stroke="black" d="M183.26,-32.73C183.26,-34.53 171.15,-36 156.26,-36 141.36,-36 129.26,-34.53 129.26,-32.73 129.26,-32.73 129.26,-3.27 129.26,-3.27 129.26,-1.47 141.36,0 156.26,0 171.15,0 183.26,-1.47 183.26,-3.27 183.26,-3.27 183.26,-32.73 183.26,-32.73"/>

<path fill="none" stroke="black" d="M183.26,-32.73C183.26,-30.92 171.15,-29.45 156.26,-29.45 141.36,-29.45 129.26,-30.92 129.26,-32.73"/>

<text text-anchor="middle" x="156.26" y="-14.3" font-family="Times,serif" font-size="14.00">Global</text>

</g>

<!-- Global.X&#45;&gt;Global_2 -->

<g id="edge3" class="edge">

<title>Global.X&#45;&gt;Global_2</title>

<path fill="none" stroke="black" d="M156.26,-72.81C156.26,-64.79 156.26,-55.05 156.26,-46.07"/>

<polygon fill="black" stroke="black" points="159.76,-46.03 156.26,-36.03 152.76,-46.03 159.76,-46.03"/>

</g>

</g>

</svg>
<h2>State</h2><h3>Global State</h3><table>
      <tr>
        <th>Name</th>
        <th>Description</th>
        <th>Type</th>
        <th>Symbol</th>
        <th>Domain</th>
      </tr><tr><td>X</td><td></td><td>X Type</td><td></td><td></td></tr><tr><td>Iteration Step</td><td></td><td>Number of Iterations Type</td><td></td><td></td></tr><tr><td>t</td><td></td><td>Seconds Type</td><td></td><td></td></tr><tr><td>Y</td><td></td><td>Objective Value Type</td><td></td><td></td></tr><tr><td>Y Prime</td><td></td><td>Objective Derivative Value Type</td><td></td><td></td></tr></table><h3>Local States</h3><h4>Global State</h4><table>
      <tr>
        <th>Name</th>
        <th>Description</th>
        <th>Type</th>
        <th>Symbol</th>
        <th>Domain</th>
      </tr><tr><td>X</td><td></td><td>X Type</td><td></td><td></td></tr><tr><td>Iteration Step</td><td></td><td>Number of Iterations Type</td><td></td><td></td></tr><tr><td>t</td><td></td><td>Seconds Type</td><td></td><td></td></tr><tr><td>Y</td><td></td><td>Objective Value Type</td><td></td><td></td></tr><tr><td>Y Prime</td><td></td><td>Objective Derivative Value Type</td><td></td><td></td></tr></table><h2>Spaces</h2><h3>Terminating Space</h3><p>{}</p><h3>Empty Space</h3><p>{}</p><h3>Initialization Space</h3><p>{}</p><h3>Update X Space</h3><p>{x: X Type}</p><h3>Update Y Space</h3><p>{y: Objective Value Type}</p><h3>Update Y Prime Space</h3><p>{y_prime: Objective Derivative Value Type}</p><h3>None Space</h3><p>{}</p><h3>Computation Time Metric Space</h3><p>{simulation_time: Seconds Type,<br/>computation_time: Seconds Type,<br/>action_name: Action Name Type}</p><h3>State Metric Space</h3><p>{simulation_time: Seconds Type,<br/>x: X Type,<br/>y: Objective Value Type,<br/>y_prime: Objective Derivative Value Type,<br/>iteration_step: Number of Iterations Type}</p><h2>Behavioral Action Space</h2><h2>Control Action Space</h2><h3>Initialization Control Action</h3><p>Control action to begin the simulation</p><h4>Constraints:</h4>
<h4>Control Action Options:</h4>
<details><summary><b>1. Set X = 0</b></summary><p>Simply sets the starting value of X to be equal to 0.</p><p>Logic: STATE[0].X = 0</p></details><br/><h2>Policies</h2><h3>Iteration Controller Policy</h3><p>The policy which controls whether another iteration should take place in a simulation.</p><h4>Preceded By:</h4>
<h4>Domain Spaces:</h4>
<p>1. Empty Space</p><h4>Followed By:</h4>
<p>1. Iteration Policy</p><h4>Codomain Spaces:</h4>
<p>1. Empty Space</p><h4>Constraints:</h4>
<h4>Policy Options:</h4>
<details><summary><b>1. Constant Iterations Policy Option</b></summary><p>A policy option which runs a constant number of iterations for any simulation.</p><p>Logic: If state["iteration_step"] < params["max_iterations"], call the iteration policy, otherwise terminate</p></details><details><summary><b>2. Tolerance Policy Option</b></summary><p>A policy option which runs a constant number of iterations for any simulation unless abs(y) is less than a tolerance.</p><p>Logic: If state["iteration_step"] < params["max_iterations"] and abs(state["y"]) > params["tolerance"], call the iteration policy, otherwise terminate</p></details><br/><h3>Iteration Policy</h3><p>The policy which produces one iteration of the root finding algorithm.</p><h4>Preceded By:</h4>
<p>1. Iteration Controller Policy</p><h4>Domain Spaces:</h4>
<p>1. Empty Space</p><h4>Followed By:</h4>
<p>1. Update X Mechanism</p><p>2. Log Computation Time Metric Mechanism</p><h4>Codomain Spaces:</h4>
<p>1. Update X Space</p><p>2. Computation Time Metric Space</p><h4>Constraints:</h4>
<h3>Calculate Y Policy</h3><p>The policy which calculates the value for f.</p><h4>Preceded By:</h4>
<h4>Domain Spaces:</h4>
<p>1. Empty Space</p><h4>Followed By:</h4>
<p>1. Update Y Mechanism</p><p>2. Log Computation Time Metric Mechanism</p><h4>Codomain Spaces:</h4>
<p>1. Update Y Space</p><p>2. Computation Time Metric Space</p><h4>Constraints:</h4>
<h4>Policy Options:</h4>
<details><summary><b>1. Calculate Y Policy Basic</b></summary><p>Basic solving.</p><p>Logic: y = params["f"](state["x"])</p></details><br/><h3>Calculate Y Prime Policy</h3><p>The policy which calculates the value for the derivative of f.</p><h4>Preceded By:</h4>
<h4>Domain Spaces:</h4>
<p>1. Empty Space</p><h4>Followed By:</h4>
<p>1. Update Y Prime Mechanism</p><p>2. Log Computation Time Metric Mechanism</p><h4>Codomain Spaces:</h4>
<p>1. Update Y Prime Space</p><p>2. Computation Time Metric Space</p><h4>Constraints:</h4>
<h4>Policy Options:</h4>
<details><summary><b>1. Calculate Y Prime Policy Basic</b></summary><p>Basic solving.</p><p>Logic: y_prime = params["f_prime"](state["X"])</p></details><br/><h2>Mechanisms</h2><h3>Update X Mechanism</h3><p>Mechanism for update to the x value</p><h4>Preceded By:</h4>
<p>1. Iteration Policy</p><p>2. Initialization Control Action</p><h4>Domain Spaces:</h4>
<p>1. Update X Space</p><h4>State Updates:</h4>
<p>1. Global.X</p><h4>Constraints:</h4>
<h4>Logic:</h4>
<p>Change the global state variable of X to be equal to DOMAIN[0].X</p><h3>Increment Iteration Step Mechanism</h3><p>Mechanism for incrementing the iteration step by 1</p><h4>Preceded By:</h4>
<h4>Domain Spaces:</h4>
<p>1. Empty Space</p><h4>State Updates:</h4>
<p>1. Global.Iteration Step</p><h4>Constraints:</h4>
<h4>Logic:</h4>
<p>state['iteration_step'] += 1</p><h3>Set Simulation Time Mechanism</h3><p>Mechanism for setting the current time of the simulation</p><h4>Preceded By:</h4>
<h4>Domain Spaces:</h4>
<p>1. Empty Space</p><h4>State Updates:</h4>
<p>1. Global.t</p><h4>Constraints:</h4>
<h4>Logic:</h4>
<p>state['simulation_time'] = now()</p><h3>Update Y Mechanism</h3><p>Mechanism for an update to the y value</p><h4>Preceded By:</h4>
<p>1. Calculate Y Policy</p><h4>Domain Spaces:</h4>
<p>1. Update Y Space</p><h4>State Updates:</h4>
<p>1. Global.Y</p><h4>Constraints:</h4>
<h4>Logic:</h4>
<p>Update the global state variable of Y to be equal to DOMAIN[0].Y</p><h3>Update Y Prime Mechanism</h3><p>Mechanism for an update to the y_prime value</p><h4>Preceded By:</h4>
<p>1. Calculate Y Prime Policy</p><h4>Domain Spaces:</h4>
<p>1. Update Y Prime Space</p><h4>State Updates:</h4>
<p>1. Global.Y Prime</p><h4>Constraints:</h4>
<h4>Logic:</h4>
<p>Update the global state variable of Y Prime to be equal to DOMAIN[0].Y Prime</p><h3>Log Computation Time Metric Mechanism</h3><p>The computation time metric is logged here</p><h4>Preceded By:</h4>
<p>1. Calculate Y Prime Policy</p><p>2. Iteration Policy</p><p>3. Calculate Y Policy</p><h4>Domain Spaces:</h4>
<p>1. Computation Time Metric Space</p><h4>State Updates:</h4>
<h4>Constraints:</h4>
<h4>Logic:</h4>
<p></p><h3>Log State Metric Mechanism</h3><p>The state metric is logged here</p><h4>Preceded By:</h4>
<h4>Domain Spaces:</h4>
<p>1. State Metric Space</p><h4>State Updates:</h4>
<h4>Constraints:</h4>
<h4>Logic:</h4>
<p></p><h2>Parameters</h2><h3>max_iterations</h3><p>Description: The maximum number of iterations for the simulation</p><p>Symbol: None</p><p>Domain: None</p><p>Parameter Class: System</p><h3>tolerance</h3><p>Description: The tolerance to determine if iteartions can stop</p><p>Symbol: None</p><p>Domain: None</p><p>Parameter Class: System</p><h3>f</h3><p>Description: The objective function</p><p>Symbol: None</p><p>Domain: None</p><p>Parameter Class: Behavioral</p><h3>f_prime</h3><p>Description: The objective function derivative</p><p>Symbol: None</p><p>Domain: None</p><p>Parameter Class: Behavioral</p><h3>root_finding_method</h3><p>Description: The functional parameterization for the root finding method to use</p><p>Symbol: None</p><p>Domain: None</p><p>Parameter Class: Functional</p>